#include "melt.h"

/**
 *     Инициализация SPI контроллера
 *          Требуемые данные:
 *
 * Пины:   GP_PP    -> LCD_RES
 *         SPI_CLK  -> LCD_SCL
 *         GP_PP    -> LCD_A0
 *         SPI_MOSI -> LCD_SI
 *         GP_PP    -> LCD_CSI
 *
 * Режим SPI: 1   -   1
 *            ---- ----
 *            CPOL CPHA
 *            ---- ----
 *            Пол. Фаза
 *
 * Выбор слейва за контроллером
 * Направление работы - мастер
 **/

#include <alloca.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>

[[gnu::weak]] extern void melt_hardware(void) {
    /**
     * GP_PP:      MELT_RES
     * SPI_CLK:    MELT_SCL
     * GP_PP:      MELT_A0
     * SPI_MOSI:   MELT_SI
     * GP_PP:      MELT_CSI
     *
     * Enable SPI
     **/
}

[[gnu::weak]] extern void melt_send([[maybe_unused]] uint8_t data, [[maybe_unused]] uint8_t a0) {
    /**
     * MELT_A0(a0);
     *
     * while (!(SPI_TX_IS_EMPTY));
     *
     * SPI_DATA_REGISTER = data;
     **/
}

[[gnu::weak]] extern void melt_init(void) {
    /**
     * static const uint8_t cmd[] = {0x2F, 0x27, 0x89, 0x00, 0x81, 0x30, 0x40, 0xA6, 0xC8, 0xA0, 0xAF};
     * enum { TIMEOUT = USHRT_MAX };
     * melt_hardware();
     *
     * MELT_RES(0);
     * MELT_CSI(1);
     * for (size_t i = 0; i < TIMEOUT; i++);
     * MELT_RES(1);
     * MELT_CSI(0);
     * for (size_t i = 0; i < sizeof_array(cmd); i++)
     *     melt_send_command(cmd[i]);
     * melt_pour_all(MODE_CLEAR);
     **/
}

extern void melt_send_data(uint8_t data) { melt_send(data, 1); }

extern void melt_send_command(uint8_t cmd) { melt_send(cmd, 0); }

extern void melt_address(uint8_t a) {
    const uint8_t cmd[] = {0x10 | (a >> 4), 0x0F & a};
    for (size_t i = 0; i < sizeof_array(cmd); i++) /*  */
        melt_send_command(cmd[i]);
}

extern void melt_pour_all(mode_t mode) {
    for (uint8_t str = 0; str < (MELT_HEIGHT / 8); str++) {
        const uint8_t cmd[] = {0xB0 + str, 0x10, 0x00};
        for (size_t i = 0; i < sizeof_array(cmd); i++) /*  */
            melt_send_command(cmd[i]);
        for (uint8_t col = 0; col < MELT_WIDTH; col++) {
            switch (mode) {
            case MODE_DRAW:
                screen[str][col] |= UCHAR_MAX;
                break;
            case MODE_CLEAR:
                screen[str][col] = 0x00;
                break;
            case MODE_INVERT:
                screen[str][col] ^= UCHAR_MAX;
                break;
            }
            melt_send_data(screen[str][col]);
        }
    }
}

extern void melt_pour_area(mode_t mode, uint8_t str, uint8_t col, uint8_t height, uint8_t width) {
    for (uint8_t add = 0; (add < height) && (str + add < MELT_HEIGHT); add++)
        melt_draw_line_horizontal(mode, str + add, col, width);
}

extern void melt_pour_bitmap(mode_t mode, uint8_t str, uint8_t col, uint8_t *image, uint8_t height, uint8_t width) {
    if (str >= MELT_HEIGHT && col >= MELT_WIDTH)
        return;

    for (uint8_t x = 0; (x < width) && (col + x < MELT_WIDTH); x++) {
        union qword full = {0};
        uint8_t local = col + x;
        for (uint8_t y = 0; (y < height) && ((y * 8) < MELT_HEIGHT); y++) {
            uint8_t shift = str + (y * 8);
            if (shift < 32)
                full.dword[0] |= image[(y * width) + x] << shift;
            if (shift > 24)
                full.dword[1] |=
                    (shift > 32) ? image[(y * width) + x] << (shift - 32) : image[(y * width) + x] >> (32 - shift);
        }
        for (uint8_t y = 0; y < (MELT_HEIGHT / 8); y++) {
            const uint8_t cmd[] = {0xB0 + y, 0x10 + (local / 16), local % 16};
            for (size_t i = 0; i < sizeof_array(cmd); i++) /*  */
                melt_send_command(cmd[i]);
            switch (mode) {
            case MODE_DRAW:
                screen[y][local] |= full.byte[y];
                break;
            case MODE_CLEAR:
                screen[y][local] &= ~full.byte[y];
                break;
            case MODE_INVERT:
                screen[y][local] ^= full.byte[y];
                break;
            }
            melt_send_data(screen[y][local]);
        }
    }
}

extern void melt_draw_pixel(mode_t mode, uint8_t str, uint8_t col) {
    if (str >= MELT_HEIGHT && col >= MELT_WIDTH)
        return;

    const uint8_t l = str / 8, s = str % 8, cmd[] = {0xB0 + l, 0x10 + (col / 16), col % 16};
    for (size_t i = 0; i < sizeof_array(cmd); i++) /*  */
        melt_send_command(cmd[i]);
    switch (mode) {
    case MODE_DRAW:
        screen[l][col] |= 1 << s;
        break;
    case MODE_CLEAR:
        screen[l][col] &= ~(1 << s);
        break;
    case MODE_INVERT:
        screen[l][col] ^= 1 << s;
        break;
    }
    melt_send_data(screen[l][col]);
}

extern void melt_draw_line_horizontal(mode_t mode, uint8_t str, uint8_t col, uint8_t len) {
    for (uint8_t add = 0; (add < len) && (col + add < MELT_WIDTH); add++) /*  */
        melt_draw_pixel(mode, str, col + add);
}

extern void melt_draw_line_vertical(mode_t mode, uint8_t str, uint8_t col, uint8_t len) {
    for (uint8_t add = 0; (add < len) && (str + add < MELT_HEIGHT); add++) /*  */
        melt_draw_pixel(mode, str + add, col);
}

extern void melt_draw_line_arbitrary(mode_t mode, uint8_t str_from, uint8_t col_from, uint8_t str_to, uint8_t col_to) {
    int8_t dx = col_to - col_from, dy = str_to - str_from, mx = (abs(dx) > abs(dy)) ? dx : dy;
    int32_t tang = (abs(dx) > abs(dy)) ? (dy << 10) / dx : (dx << 10) / dy;

    for (int8_t it = 0; it != mx; (mx > 0) ? it++ : it--) {
        uint8_t first_add = (abs(dx) > abs(dy)) ? str_from + ((it * tang) >> 10) : str_from + it,
                second_add = (abs(dx) > abs(dy)) ? col_from + it : col_from + ((it * tang) >> 10);
        melt_draw_pixel(mode, first_add, second_add);
    }
}

extern void melt_draw_rectangle(mode_t mode, uint8_t str, uint8_t col, uint8_t height, uint8_t width) {
    melt_draw_line_horizontal(mode, str, col, width);
    melt_draw_line_vertical(mode, str + 1, col + width - 1, height - 1);
    melt_draw_line_vertical(mode, str + 1, col, height - 1);
    melt_draw_line_horizontal(mode, str + height - 1, col + 1, width - 2);
}

extern void melt_draw_circle(mode_t mode, uint8_t str, uint8_t col, uint8_t rad) {
    for (int8_t x = 0, y = rad, magic = 3 - 2 * rad;;) {
        melt_draw_pixel(mode, y + str, x + col);
        melt_draw_pixel(mode, -y + str, x + col);
        melt_draw_pixel(mode, -y + str, -x + col);
        melt_draw_pixel(mode, y + str, -x + col);
        melt_draw_pixel(mode, x + str, y + col);
        melt_draw_pixel(mode, -x + str, y + col);
        melt_draw_pixel(mode, -x + str, -y + col);
        melt_draw_pixel(mode, x + str, -y + col);

        if (x >= y)
            break;

        if (magic <= 0)
            magic += 4 * x + 6;
        else
            magic += 4 * (x - y) + 10, y--;

        x++;
    }
}

/* Author: http://code.google.com/p/convert-utf8-to-cp1251/ */

typedef struct letter {
    uint8_t win1251;
    wchar_t utf;
} letter_t;

static const letter_t g_letters[] = {
    {0x82, 0x201A}, {0x83, 0x0453}, {0x84, 0x201E}, {0x85, 0x2026}, {0x86, 0x2020}, {0x87, 0x2021}, {0x88, 0x20AC},
    {0x89, 0x2030}, {0x8A, 0x0409}, {0x8B, 0x2039}, {0x8C, 0x040A}, {0x8D, 0x040C}, {0x8E, 0x040B}, {0x8F, 0x040F},
    {0x90, 0x0452}, {0x91, 0x2018}, {0x92, 0x2019}, {0x93, 0x201C}, {0x94, 0x201D}, {0x95, 0x2022}, {0x96, 0x2013},
    {0x97, 0x2014}, {0x99, 0x2122}, {0x9A, 0x0459}, {0x9B, 0x203A}, {0x9C, 0x045A}, {0x9D, 0x045C}, {0x9E, 0x045B},
    {0x9F, 0x045F}, {0xA0, 0x00A0}, {0xA1, 0x040E}, {0xA2, 0x045E}, {0xA3, 0x0408}, {0xA4, 0x00A4}, {0xA5, 0x0490},
    {0xA6, 0x00A6}, {0xA7, 0x00A7}, {0xA8, 0x0401}, {0xA9, 0x00A9}, {0xAA, 0x0404}, {0xAB, 0x00AB}, {0xAC, 0x00AC},
    {0xAD, 0x00AD}, {0xAE, 0x00AE}, {0xAF, 0x0407}, {0xB0, 0x00B0}, {0xB1, 0x00B1}, {0xB2, 0x0406}, {0xB3, 0x0456},
    {0xB4, 0x0491}, {0xB5, 0x00B5}, {0xB6, 0x00B6}, {0xB7, 0x00B7}, {0xB8, 0x0451}, {0xB9, 0x2116}, {0xBA, 0x0454},
    {0xBB, 0x00BB}, {0xBC, 0x0458}, {0xBD, 0x0405}, {0xBE, 0x0455}, {0xBF, 0x0457}};

static ssize_t utf8_to_win1251(uint8_t *data, size_t size) {
    ssize_t j = 0;

    if (data == NULL || size == 0)
        return -1;

    for (size_t i = 0; i < size && data[i] != '\0'; i++) {
        uint8_t prefix = data[i];
        if ((prefix & 0x80) == 0) {
            data[j] = prefix;
            j++;
        } else if ((~prefix) & 0x20 && i + 1 < size) {
            wchar_t first5bit = (wchar_t)(prefix & 0x1F) << 6, sec6bit = data[i + 1] & 0x3F,
                    unicode_char = first5bit + sec6bit;
            if (unicode_char >= 0x410 && unicode_char <= 0x44F)
                data[j] = (uint8_t)(unicode_char - 0x350);
            else if (unicode_char >= 0x80 && unicode_char <= 0xFF)
                data[j] = (uint8_t)(unicode_char);
            else if (unicode_char >= 0x402 && unicode_char <= 0x403)
                data[j] = (uint8_t)(unicode_char - 0x382);
            else {
                size_t count = sizeof(g_letters) / sizeof(letter_t);
                for (size_t k = 0; k < count; k++) {
                    if (unicode_char == g_letters[k].utf) {
                        data[j] = g_letters[k].win1251;
                        goto next;
                    }
                }
                return -1;
            }
        next:
            i++, j++;
        } else
            return -1;
    }
    data[j++] = '\0';

    return j;
}

[[gnu::__noinline__]] extern void melt_printf(mode_t mode, uint8_t str, uint8_t col, const uint8_t *fmt, ...) {
    va_list args;
    volatile ssize_t size;
    uint8_t *out;

    if (str >= MELT_HEIGHT || fmt == NULL)
        return;

    va_start(args, fmt);
    size = vsnprintf(NULL, 0, (const char *)fmt, args) + sizeof_array("");
    va_end(args);

    out = (uint8_t *)alloca(size * sizeof(uint8_t));
    if (out == NULL)
        return;

    va_start(args, fmt);
    vsnprintf((char *)out, size, (const char *)fmt, args);
    va_end(args);

    size = utf8_to_win1251(out, size);
    if (size < 0)
        return;

    for (ssize_t i = 0; i < size && out[i] != '\0'; i++) {
        uint8_t c = col + (7 * i);
        if (c < MELT_WIDTH)
            melt_pour_bitmap(mode, str, c, &font[out[i] * 6], 1, 6);
        else
            break;
    }
}

uint8_t screen[MELT_HEIGHT / CHAR_BIT][MELT_WIDTH] = {0};
uint8_t font[FONT_SYMBOLS] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x55, 0x54, 0x55, 0x08, 0x00, 0x3E, 0x6B, 0x6F, 0x6B, 0x3E, 0x00,
    0x1C, 0x3E, 0x7C, 0x3E, 0x1C, 0x00, 0x18, 0x3C, 0x7E, 0x3C, 0x18, 0x00, 0x30, 0x36, 0x7F, 0x36, 0x30, 0x00, 0x18,
    0x5C, 0x7E, 0x5C, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0xFF, 0xFF, 0xE7, 0xE7, 0xFF, 0xFF, 0x00, 0x3C, 0x24,
    0x24, 0x3C, 0x00, 0xFF, 0xC3, 0xDB, 0xDB, 0xC3, 0xFF, 0x00, 0x30, 0x48, 0x4A, 0x36, 0x0E, 0x00, 0x06, 0x29, 0x79,
    0x29, 0x06, 0x00, 0x60, 0x70, 0x3F, 0x02, 0x04, 0x00, 0x60, 0x7E, 0x0A, 0x35, 0x3F, 0x00, 0x2A, 0x1C, 0x36, 0x1C,
    0x2A, 0x00, 0x00, 0x7F, 0x3E, 0x1C, 0x08, 0x00, 0x08, 0x1C, 0x3E, 0x7F, 0x00, 0x00, 0x14, 0x36, 0x7F, 0x36, 0x14,
    0x00, 0x00, 0x5F, 0x00, 0x5F, 0x00, 0x00, 0x06, 0x09, 0x7F, 0x01, 0x7F, 0x00, 0x22, 0x4D, 0x55, 0x59, 0x22, 0x00,
    0x60, 0x60, 0x60, 0x60, 0x00, 0x00, 0x14, 0xB6, 0xFF, 0xB6, 0x14, 0x00, 0x04, 0x06, 0x7F, 0x06, 0x04, 0x00, 0x10,
    0x30, 0x7F, 0x30, 0x10, 0x00, 0x08, 0x08, 0x3E, 0x1C, 0x08, 0x00, 0x08, 0x1C, 0x3E, 0x08, 0x08, 0x00, 0x78, 0x40,
    0x40, 0x40, 0x40, 0x00, 0x08, 0x3E, 0x08, 0x3E, 0x08, 0x00, 0x30, 0x3C, 0x3F, 0x3C, 0x30, 0x00, 0x03, 0x0F, 0x3F,
    0x0F, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x5F, 0x06, 0x00, 0x00, 0x07, 0x03, 0x00, 0x07,
    0x03, 0x00, 0x24, 0x7E, 0x24, 0x7E, 0x24, 0x00, 0x24, 0x2B, 0x6A, 0x12, 0x00, 0x00, 0x63, 0x13, 0x08, 0x64, 0x63,
    0x00, 0x36, 0x49, 0x56, 0x20, 0x50, 0x00, 0x00, 0x07, 0x03, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x41, 0x00, 0x00, 0x00,
    0x00, 0x41, 0x3E, 0x00, 0x00, 0x00, 0x08, 0x3E, 0x1C, 0x3E, 0x08, 0x00, 0x08, 0x08, 0x3E, 0x08, 0x08, 0x00, 0x00,
    0xE0, 0x60, 0x00, 0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x60, 0x60, 0x00, 0x00, 0x00, 0x20, 0x10,
    0x08, 0x04, 0x02, 0x00, 0x3E, 0x41, 0x41, 0x41, 0x3E, 0x00, 0x00, 0x42, 0x7F, 0x40, 0x00, 0x00, 0x62, 0x51, 0x49,
    0x49, 0x46, 0x00, 0x22, 0x49, 0x49, 0x49, 0x36, 0x00, 0x18, 0x14, 0x12, 0x7F, 0x10, 0x00, 0x2F, 0x49, 0x49, 0x49,
    0x31, 0x00, 0x3C, 0x4A, 0x49, 0x49, 0x30, 0x00, 0x01, 0x71, 0x09, 0x05, 0x03, 0x00, 0x36, 0x49, 0x49, 0x49, 0x36,
    0x00, 0x06, 0x49, 0x49, 0x29, 0x1E, 0x00, 0x00, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0xEC, 0x6C, 0x00, 0x00, 0x00,
    0x08, 0x14, 0x22, 0x41, 0x00, 0x00, 0x24, 0x24, 0x24, 0x24, 0x24, 0x00, 0x00, 0x41, 0x22, 0x14, 0x08, 0x00, 0x02,
    0x01, 0x59, 0x09, 0x06, 0x00, 0x3E, 0x41, 0x5D, 0x55, 0x1E, 0x00, 0x7E, 0x11, 0x11, 0x11, 0x7E, 0x00, 0x7F, 0x49,
    0x49, 0x49, 0x36, 0x00, 0x3E, 0x41, 0x41, 0x41, 0x22, 0x00, 0x7F, 0x41, 0x41, 0x41, 0x3E, 0x00, 0x7F, 0x49, 0x49,
    0x49, 0x41, 0x00, 0x7F, 0x09, 0x09, 0x09, 0x01, 0x00, 0x3E, 0x41, 0x49, 0x49, 0x7A, 0x00, 0x7F, 0x08, 0x08, 0x08,
    0x7F, 0x00, 0x00, 0x41, 0x7F, 0x41, 0x00, 0x00, 0x30, 0x40, 0x40, 0x40, 0x3F, 0x00, 0x7F, 0x08, 0x14, 0x22, 0x41,
    0x00, 0x7F, 0x40, 0x40, 0x40, 0x40, 0x00, 0x7F, 0x02, 0x04, 0x02, 0x7F, 0x00, 0x7F, 0x02, 0x04, 0x08, 0x7F, 0x00,
    0x3E, 0x41, 0x41, 0x41, 0x3E, 0x00, 0x7F, 0x09, 0x09, 0x09, 0x06, 0x00, 0x3E, 0x41, 0x51, 0x21, 0x5E, 0x00, 0x7F,
    0x09, 0x09, 0x19, 0x66, 0x00, 0x26, 0x49, 0x49, 0x49, 0x32, 0x00, 0x01, 0x01, 0x7F, 0x01, 0x01, 0x00, 0x3F, 0x40,
    0x40, 0x40, 0x3F, 0x00, 0x1F, 0x20, 0x40, 0x20, 0x1F, 0x00, 0x3F, 0x40, 0x3C, 0x40, 0x3F, 0x00, 0x63, 0x14, 0x08,
    0x14, 0x63, 0x00, 0x07, 0x08, 0x70, 0x08, 0x07, 0x00, 0x71, 0x49, 0x45, 0x43, 0x00, 0x00, 0x00, 0x7F, 0x41, 0x41,
    0x00, 0x00, 0x02, 0x04, 0x08, 0x10, 0x20, 0x00, 0x00, 0x41, 0x41, 0x7F, 0x00, 0x00, 0x04, 0x02, 0x01, 0x02, 0x04,
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x03, 0x07, 0x00, 0x00, 0x00, 0x20, 0x54, 0x54, 0x54, 0x78, 0x00,
    0x7F, 0x44, 0x44, 0x44, 0x38, 0x00, 0x38, 0x44, 0x44, 0x44, 0x28, 0x00, 0x38, 0x44, 0x44, 0x44, 0x7F, 0x00, 0x38,
    0x54, 0x54, 0x54, 0x08, 0x00, 0x08, 0x7E, 0x09, 0x09, 0x00, 0x00, 0x18, 0xA4, 0xA4, 0xA4, 0x7C, 0x00, 0x7F, 0x04,
    0x04, 0x78, 0x00, 0x00, 0x00, 0x00, 0x7D, 0x40, 0x00, 0x00, 0x40, 0x80, 0x84, 0x7D, 0x00, 0x00, 0x7F, 0x10, 0x28,
    0x44, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x40, 0x00, 0x00, 0x7C, 0x04, 0x18, 0x04, 0x78, 0x00, 0x7C, 0x04, 0x04, 0x78,
    0x00, 0x00, 0x38, 0x44, 0x44, 0x44, 0x38, 0x00, 0xFC, 0x44, 0x44, 0x44, 0x38, 0x00, 0x38, 0x44, 0x44, 0x44, 0xFC,
    0x00, 0x44, 0x78, 0x44, 0x04, 0x08, 0x00, 0x08, 0x54, 0x54, 0x54, 0x20, 0x00, 0x04, 0x3E, 0x44, 0x24, 0x00, 0x00,
    0x3C, 0x40, 0x20, 0x7C, 0x00, 0x00, 0x1C, 0x20, 0x40, 0x20, 0x1C, 0x00, 0x3C, 0x60, 0x30, 0x60, 0x3C, 0x00, 0x6C,
    0x10, 0x10, 0x6C, 0x00, 0x00, 0x9C, 0xA0, 0x60, 0x3C, 0x00, 0x00, 0x64, 0x54, 0x54, 0x4C, 0x00, 0x00, 0x08, 0x3E,
    0x41, 0x41, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x00, 0x00, 0x00, 0x41, 0x41, 0x3E, 0x08, 0x00, 0x02, 0x01, 0x02,
    0x01, 0x00, 0x00, 0x3C, 0x26, 0x23, 0x26, 0x3C, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0xAA, 0x55, 0xAA, 0x55, 0xAA,
    0x55, 0xBB, 0xEE, 0xBB, 0xEE, 0xBB, 0xEE, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x08, 0x08, 0x08, 0xFF, 0x00, 0x00,
    0x0A, 0x0A, 0x0A, 0xFF, 0x00, 0x00, 0x08, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x08, 0xF8, 0x08, 0xF8, 0x00, 0x00, 0x0A,
    0x0A, 0x0A, 0xFE, 0x00, 0x00, 0x0A, 0xFB, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x0A, 0xFA,
    0x02, 0xFE, 0x00, 0x00, 0x0A, 0x0B, 0x08, 0x0F, 0x00, 0x00, 0x08, 0x0F, 0x08, 0x0F, 0x00, 0x00, 0x0A, 0x0A, 0x0A,
    0x0F, 0x00, 0x00, 0x08, 0x08, 0x08, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0F,
    0x08, 0x08, 0x08, 0x08, 0x08, 0xF8, 0x08, 0x08, 0x00, 0x00, 0x00, 0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
    0x08, 0x08, 0x08, 0x08, 0xFF, 0x08, 0x08, 0x00, 0x00, 0x00, 0xFF, 0x0A, 0x0A, 0x00, 0xFF, 0x00, 0xFF, 0x08, 0x08,
    0x00, 0x0F, 0x08, 0x0B, 0x0A, 0x0A, 0x00, 0xFE, 0x02, 0xFA, 0x0A, 0x0A, 0x0A, 0x0B, 0x08, 0x0B, 0x0A, 0x0A, 0x0A,
    0xFA, 0x02, 0xFA, 0x0A, 0x0A, 0x00, 0xFF, 0x00, 0xFB, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0xFB,
    0x00, 0xFB, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0B, 0x0A, 0x0A, 0x08, 0x0F, 0x08, 0x0F, 0x08, 0x08, 0x0A, 0x0A, 0x0A,
    0xFA, 0x0A, 0x0A, 0x08, 0xF8, 0x08, 0xF8, 0x08, 0x08, 0x00, 0x0F, 0x08, 0x0F, 0x08, 0x08, 0x00, 0x00, 0x00, 0x0F,
    0x0A, 0x0A, 0x00, 0x00, 0x00, 0xFE, 0x0A, 0x0A, 0x00, 0xF8, 0x08, 0xF8, 0x08, 0x08, 0x08, 0xFF, 0x08, 0xFF, 0x08,
    0x08, 0x00, 0x7E, 0x4B, 0x4A, 0x4B, 0x42, 0x0A, 0x0A, 0x0A, 0xFF, 0x0A, 0x0A, 0x08, 0x08, 0x08, 0x0F, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xF8, 0x08, 0x08, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xFF,
    0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x00, 0x7E,
    0x4B, 0x4A, 0x4B, 0x42, 0x00, 0x38, 0x54, 0x54, 0x44, 0x28, 0x00, 0x01, 0x40, 0x7E, 0x40, 0x01, 0x00, 0x00, 0x01,
    0x7C, 0x41, 0x00, 0x00, 0x27, 0x48, 0x4B, 0x48, 0x3F, 0x00, 0x9D, 0xA2, 0x62, 0x3D, 0x00, 0x00, 0x06, 0x09, 0x09,
    0x06, 0x00, 0x00, 0x38, 0x55, 0x54, 0x55, 0x08, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00,
    0x00, 0x00, 0x30, 0x40, 0x3E, 0x02, 0x02, 0x7F, 0x06, 0x18, 0x7F, 0x13, 0x13, 0x2A, 0x3E, 0x14, 0x14, 0x3E, 0x2A,
    0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x11, 0x11, 0x11, 0x7E, 0x00,
    0x7F, 0x49, 0x49, 0x49, 0x31, 0x00, 0x7F, 0x49, 0x49, 0x49, 0x36, 0x00, 0x7F, 0x01, 0x01, 0x01, 0x01, 0xC0, 0x7E,
    0x41, 0x41, 0x7F, 0xC0, 0x00, 0x7F, 0x49, 0x49, 0x49, 0x41, 0x00, 0x77, 0x08, 0x7F, 0x08, 0x77, 0x22, 0x49, 0x49,
    0x49, 0x36, 0x00, 0x00, 0x7F, 0x20, 0x10, 0x08, 0x7F, 0x00, 0x7E, 0x21, 0x11, 0x09, 0x7E, 0x00, 0x7F, 0x08, 0x14,
    0x22, 0x41, 0x00, 0x40, 0x7E, 0x01, 0x01, 0x7F, 0x00, 0x7F, 0x02, 0x04, 0x02, 0x7F, 0x00, 0x7F, 0x08, 0x08, 0x08,
    0x7F, 0x00, 0x3E, 0x41, 0x41, 0x41, 0x3E, 0x00, 0x7F, 0x01, 0x01, 0x01, 0x7F, 0x00, 0x7F, 0x09, 0x09, 0x09, 0x06,
    0x00, 0x3E, 0x41, 0x41, 0x41, 0x22, 0x00, 0x01, 0x01, 0x7F, 0x01, 0x01, 0x00, 0x27, 0x48, 0x48, 0x48, 0x3F, 0x00,
    0x0E, 0x11, 0x7F, 0x11, 0x0E, 0x00, 0x63, 0x14, 0x08, 0x14, 0x63, 0x00, 0x7F, 0x40, 0x40, 0x7F, 0xC0, 0x00, 0x07,
    0x08, 0x08, 0x08, 0x7F, 0x00, 0x7F, 0x40, 0x7F, 0x40, 0x7F, 0x00, 0x7F, 0x40, 0x7F, 0x40, 0xFF, 0x03, 0x01, 0x7F,
    0x48, 0x48, 0x30, 0x00, 0x7F, 0x48, 0x48, 0x30, 0x7F, 0x00, 0x7F, 0x48, 0x48, 0x48, 0x30, 0x00, 0x22, 0x41, 0x49,
    0x49, 0x3E, 0x00, 0x7F, 0x08, 0x3E, 0x41, 0x3E, 0x00, 0x66, 0x19, 0x09, 0x09, 0x7F, 0x00, 0x20, 0x54, 0x54, 0x54,
    0x78, 0x00, 0x3C, 0x4A, 0x4A, 0x4A, 0x31, 0x00, 0x7C, 0x54, 0x54, 0x54, 0x28, 0x00, 0x7C, 0x04, 0x04, 0x0C, 0x00,
    0xC0, 0x78, 0x44, 0x44, 0x7C, 0xC0, 0x00, 0x38, 0x54, 0x54, 0x54, 0x08, 0x00, 0x6C, 0x10, 0x7C, 0x10, 0x6C, 0x00,
    0x28, 0x44, 0x54, 0x54, 0x28, 0x00, 0x7C, 0x20, 0x10, 0x08, 0x7C, 0x00, 0x7C, 0x20, 0x12, 0x0A, 0x7C, 0x00, 0x7C,
    0x10, 0x28, 0x44, 0x00, 0x40, 0x38, 0x04, 0x04, 0x7C, 0x00, 0x00, 0x7C, 0x08, 0x10, 0x08, 0x7C, 0x00, 0x7C, 0x10,
    0x10, 0x10, 0x7C, 0x00, 0x38, 0x44, 0x44, 0x44, 0x38, 0x00, 0x7C, 0x04, 0x04, 0x04, 0x7C, 0x00, 0xFC, 0x44, 0x44,
    0x44, 0x38, 0x00, 0x38, 0x44, 0x44, 0x44, 0x28, 0x00, 0x04, 0x04, 0x7C, 0x04, 0x04, 0x00, 0x9C, 0xA0, 0x60, 0x3C,
    0x00, 0x00, 0x18, 0x24, 0x7C, 0x24, 0x18, 0x00, 0x6C, 0x10, 0x10, 0x6C, 0x00, 0x00, 0x7C, 0x40, 0x40, 0x7C, 0xC0,
    0x00, 0x0C, 0x10, 0x10, 0x10, 0x7C, 0x00, 0x7C, 0x40, 0x7C, 0x40, 0x7C, 0x00, 0x7C, 0x40, 0x7C, 0x40, 0xFC, 0x0C,
    0x04, 0x7C, 0x50, 0x50, 0x20, 0x00, 0x7C, 0x50, 0x50, 0x20, 0x7C, 0x00, 0x7C, 0x50, 0x50, 0x50, 0x20, 0x00, 0x28,
    0x44, 0x54, 0x54, 0x38, 0x00, 0x7C, 0x10, 0x38, 0x44, 0x38, 0x00, 0x48, 0x34, 0x14, 0x14, 0x7C};
